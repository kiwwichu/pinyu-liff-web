<script>
// ====== Vercel API ======
const API_URL = "/api/avail";
let googleBusyDates = new Set(); // ğŸ”´ Google æ—¥æ›†æœ‰è¡Œç¨‹çš„æ—¥æœŸ

// âœ… åªæœ‰ 3 æ®µï¼ˆç„¡æ·±å¤œï¼‰
const slotLabel = {
  MORNING: "æ—©ä¸Š",
  AFTERNOON: "ä¸‹åˆ",
  EVENING: "æ™šä¸Š"
};
const SLOT_ORDER = ["MORNING","AFTERNOON","EVENING"];
const LOW_MIN_THRESHOLD = 60; // å°‘é‡é–€æª»ï¼š<=60 åˆ†é˜ â†’ é»ƒ

// drawer close
const mask = document.getElementById('mask');
const closeX = document.getElementById('closeX');
closeX.onclick = () => mask.style.display = 'none';
mask.onclick = (e) => { if (e.target === mask) mask.style.display = 'none'; };

function classify(status, mins){
  status = String(status || '').trim();
  mins = Number(mins || 0);

  if (status === 'é¡æ»¿') return 'full';
  if (status === 'å°‘é‡') return 'tight';
  if (status === 'é–‹æ”¾') return 'open';

  // fallbackï¼šå¦‚æœå¾Œç«¯æ²’çµ¦ç‹€æ…‹ï¼Œæ‰ç”¨åˆ†é˜æ¨
  if (mins <= 0) return 'full';
  if (mins <= LOW_MIN_THRESHOLD) return 'tight';
  return 'open';
}

async function fetchMonth(year, month) {
  const url = `${API_URL}?year=${encodeURIComponent(year)}&month=${encodeURIComponent(month)}`;
  const res = await fetch(url, { cache: 'no-store' });
  if (!res.ok) throw new Error(`API error ${res.status}`);
  return await res.json();
}

// è³‡æ–™æ•´ç†ï¼šdate -> {slot->item}
function groupByDate(data){
  const map = new Map();
  for (const it of (Array.isArray(data) ? data : [])) {
    const date = it.date;
    if (!map.has(date)) map.set(date, {});
    map.get(date)[it.slot] = it;
  }
  return map;
}

function markIcon(cls){
  if (cls === 'open') return 'âœ“';
  if (cls === 'tight') return 'â–³';
  return 'âœ•';
}

// ===== ç‹€æ…‹èªªæ˜æ–‡å­—ï¼ˆå‰ç«¯çµ±ä¸€ç®¡ç†ï¼‰ =====
const STATUS_DESCRIPTION = {
  open: {
    title: 'å‰©é¤˜æ™‚é–“å……è¶³ï¼Œå¯å®‰å¿ƒé ç´„',
    desc: 'ç›®å‰æ™‚æ®µå®‰æ’å½ˆæ€§ï¼Œä»æœ‰å……è¶³å¯é ç´„ç©ºé–“ã€‚'
  },
  tight: {
    title: 'åƒ…å‰©å°‘é‡åé¡ï¼Œå»ºè­°å„˜æ—©é ç´„',
    desc: 'ç›®å‰å¯ç”¨æ™‚æ®µæœ‰é™ï¼Œè‹¥æœ‰æœå‹™éœ€æ±‚ï¼Œå»ºè­°ç›¡å¿«èˆ‡ Pinyu ç¢ºèªã€‚'
  },
  full: {
    title: 'ç›®å‰å·²ç„¡å¯é ç´„åé¡',
    desc: 'æ­¤æ™‚æ®µå·²å®‰æ’æ»¿æª”ï¼Œè‹¥æœ‰å…¶ä»–æ—¥æœŸæˆ–æ™‚æ®µéœ€æ±‚ï¼Œæ­¡è¿å†èˆ‡ Pinyu è¨è«–ã€‚'
  }
};

function openDrawer(dateStr, dayObj){
  const title = document.getElementById('dTitle');
  const sub = document.getElementById('dSub');
  const list = document.getElementById('detailList');

  title.textContent = dateStr;
  sub.textContent = 'æ—©ä¸Š / ä¸‹åˆ / æ™šä¸Š';
  list.innerHTML = '';

  for (const s of SLOT_ORDER){
    const it = (dayObj && dayObj[s]) ? dayObj[s] : null;

    const start = it ? it.start : 'â€”';
    const end = it ? it.end : 'â€”';
    const mins = it ? Number(it.availableMinutes || 0) : 0;
    const status = it ? String(it.status || '').trim() : 'é¡æ»¿';

    const cls = classify(status, mins);

    const row = document.createElement('div');
    row.className = 'rowCard';

    const left = document.createElement('div');
    left.className = 'rowLeft';

    const top = document.createElement('div');
    top.className = 'rowTop';
    top.textContent = `${slotLabel[s]}  Â·  ${start}â€“${end}`;

    const meta = document.createElement('div');
    meta.className = 'rowMeta';

    const textSet = STATUS_DESCRIPTION[cls];
    if (textSet){
      meta.innerHTML = `
        <div style="font-weight:700;color:#24324a;margin-bottom:4px;">
          ${textSet.title}
        </div>
        <div style="color:#6b7a90;font-size:12px;line-height:1.5;">
          ${textSet.desc}
        </div>
      `;
    }

    left.appendChild(top);
    left.appendChild(meta);

    const badge = document.createElement('div');
    badge.className = `badge ${cls}`;
    badge.textContent = (cls === 'open') ? 'é–‹æ”¾' : (cls === 'tight' ? 'å°‘é‡' : 'é¡æ»¿');

    row.appendChild(left);
    row.appendChild(badge);
    list.appendChild(row);
  }

  mask.style.display = 'flex';
}

// ===== æœˆæ›†æ ¼å…§ä¸‰æ’ç¬¦è™Ÿï¼šèˆ‡ drawer åŒä¸€å¥— classifyï¼Œä¿è­‰ä¸€è‡´ =====
function renderDayCellSummary(dateStr, cell, grouped){
  // ğŸ”´ å¦‚æœé€™å¤©æœ‰ Google Calendar è¡Œç¨‹ â†’ æ¨™ç´…
  if (googleBusyDates.has(dateStr)) {
    cell.classList.add('gc-busy');
  }

  const dayObj = grouped.get(dateStr);
  if (!dayObj) return;

  const frame = cell.querySelector('.fc-daygrid-day-frame');
  if (!frame) return;

  // é¿å…é‡è¤‡æ¸²æŸ“
  if (frame.querySelector('.appSlots')) return;

  const wrap = document.createElement('div');
  wrap.className = 'appSlots';

  for (const key of SLOT_ORDER){
    const it = dayObj[key] || null;
    const mins = it ? Number(it.availableMinutes || 0) : 0;
    const status = it ? String(it.status || '').trim() : 'é¡æ»¿';

    const cls = classify(status, mins);
    const icon = markIcon(cls);

    const bar = document.createElement('div');
    bar.className = `appSlot ${cls}`;
    bar.textContent = icon;
    wrap.appendChild(bar);
  }

  wrap.onclick = (e) => {
    e.stopPropagation();
    selectedDateStr = dateStr;
    applySelectedStyle();
    openDrawer(dateStr, dayObj);
  };

  frame.appendChild(wrap);
}

function renderAllSummaries(){
  if (!calendar) return;

  // âœ… æ¸…æ‰èˆŠæ‘˜è¦ & èˆŠçš„ gc-busy classï¼ˆä¸ç„¶åˆ‡æœˆæœƒæ®˜ç•™ï¼‰
  document.querySelectorAll('.appSlots').forEach(el => el.remove());
  document.querySelectorAll('.fc-daygrid-day.gc-busy').forEach(el => el.classList.remove('gc-busy'));

  document.querySelectorAll('.fc-daygrid-day[data-date]').forEach(cell => {
    const dateStr = cell.getAttribute('data-date');
    renderDayCellSummary(dateStr, cell, groupedData);
  });
}

let selectedDateStr = null;
function applySelectedStyle(){
  document.querySelectorAll('.fc-daygrid-day.is-selected')
    .forEach(el => el.classList.remove('is-selected'));

  if (!selectedDateStr) return;

  const cell = document.querySelector(`.fc-daygrid-day[data-date="${selectedDateStr}"]`);
  if (cell) cell.classList.add('is-selected');
}

// ======================
// âœ… æ ¸å¿ƒï¼šåˆ‡æœˆè‡ªå‹•è¼‰å…¥
// ======================
let calendar;
let groupedData = new Map();
let loadedYear = null;
let loadedMonth = null;
let monthFetchTimer = null;

function getViewYearMonth(){
  const d = calendar.getDate();
  return { y: d.getFullYear(), m: d.getMonth() + 1 };
}

async function ensureMonthLoaded(year, month){
  // é¿å…é‡è¤‡æŠ“åŒä¸€å€‹æœˆ
  if (loadedYear === year && loadedMonth === month) {
    renderAllSummaries();
    applySelectedStyle();
    return;
  }

  const data = await fetchMonth(year, month);

  // âœ… åŒæ™‚ç›¸å®¹èˆŠ / æ–°å¾Œç«¯æ ¼å¼
  const availArr = Array.isArray(data) ? data : (data.avail || []);
  const gEvents  = Array.isArray(data) ? []   : (data.googleEvents || []);

  groupedData = groupByDate(availArr);

  // ğŸ”´ Google æ—¥æ›†ã€Œæœ‰è¡Œç¨‹çš„æ—¥æœŸã€
  googleBusyDates = new Set((gEvents || []).map(e => e.date));

  loadedYear = year;
  loadedMonth = month;

  // é¸å–æ—¥æœŸä¸åœ¨æœ¬æœˆå°±æ¸…æ‰
  if (selectedDateStr) {
    const [sy, sm] = selectedDateStr.split('-').map(Number);
    if (sy !== year || sm !== month) selectedDateStr = null;
  }

  renderAllSummaries();
  applySelectedStyle();
} // âœ… é€™å€‹å¤§æ‹¬è™Ÿä½ åŸæœ¬æ¼æ‰äº†ï¼Œå°è‡´æ•´æ®µ JS å´©æ‰

function syncInputsToView(){
  const { y, m } = getViewYearMonth();
  yearInput.value = y;
  monthInput.value = m;
}

// UI init
const yearInput = document.getElementById('year');
const monthInput = document.getElementById('month');

const now = new Date();
yearInput.value = now.getFullYear();
monthInput.value = now.getMonth() + 1;

async function initCalendar(){
  const el = document.getElementById('calendar');
  const initY = Number(yearInput.value);
  const initM = Number(monthInput.value);

  calendar = new FullCalendar.Calendar(el, {
    initialView: 'dayGridMonth',
    initialDate: `${initY}-${String(initM).padStart(2,'0')}-01`,
    height: 'auto',
    locale: 'zh-tw',

    headerToolbar: {
      left: 'prev,next today',
      center: 'title',
      right: 'dayGridMonth'
    },

    // âœ… day number åªé¡¯ç¤ºæ•¸å­—ï¼ˆå»æ‰ã€Œæ—¥ã€ï¼‰
    dayCellContent: function(arg){
      const n = String(arg.dayNumberText).match(/\d+/)?.[0] || '';
      return { html: `<span>${n}</span>` };
    },

    events: [],

    datesSet: function(){
      syncInputsToView();

      clearTimeout(monthFetchTimer);
      monthFetchTimer = setTimeout(async () => {
        try{
          const { y, m } = getViewYearMonth();
          await ensureMonthLoaded(y, m);
        }catch(err){
          console.error(err);
          alert('è¼‰å…¥å¤±æ•—ï¼š' + err.message);
        }
      }, 0);
    },

    dateClick: function(info){
      selectedDateStr = info.dateStr;
      applySelectedStyle();

      const dayObj = groupedData.get(info.dateStr);
      if (dayObj) openDrawer(info.dateStr, dayObj);
    }
  });

  calendar.render();

  // âœ… åˆæ¬¡è¼‰å…¥ç•¶æœˆ
  await ensureMonthLoaded(initY, initM);
}

document.getElementById('btnReload').onclick = async () => {
  try {
    const y = Number(yearInput.value);
    const m = Number(monthInput.value);
    calendar.gotoDate(`${y}-${String(m).padStart(2,'0')}-01`);
  } catch (err) {
    alert('è¼‰å…¥å¤±æ•—ï¼š' + err.message);
    console.error(err);
  }
};

// start
initCalendar().catch(err => {
  alert('è¼‰å…¥å¤±æ•—ï¼š' + err.message + '\n\nè«‹ç¢ºèª /api/avail æ˜¯å¦å¯å›å‚³ JSON');
  console.error(err);
});
</script>
